<!DOCTYPE html>
<html style="padding:0;margin:0;">
	<body style="padding:0;margin:0;overflow: hidden;">
		<canvas id="screen"></canvas>
		<script>
			canvascolor = "rgba(19, 23, 26, 0.3)";

			var canvas = document.getElementById('screen');
			var ctx = canvas.getContext('2d');

			var boids = [];
			var mouseX = 0;
			var mouseY = 0;
			var pause = false;
			var overlay = false;
			var mousein = false;

			// CUSTOMIZABLES!!!
			const highlights = true;
			const auras = true;
			const friction = 0.93;
			const maxspeed = 20;
			const bump = 40; // bigger = less clumped (highlighted) boids
			const mouseinfluence = 1/100;
			const scrollnumber = 5;
			const repelbump = 1/100;
			const maxcell = 10;
			const maxturn	= 0.5;
			const borderwidth = 150;
			const borderstrength = 30;

			var slidata = [
			[250, 0, 0, "Boids"],
			[200, 0, 0, "Setting 2"],
			[200, 0, 0, "Setting 3"],
			[200, 0, 0, "Setting 4"]
		];


			function dist(bo1d, x, y){
				xdist = x - bo1d.x;
				ydist = y - bo1d.y;
				if(ydist >= 0){
					originangle = Math.atan(xdist/ydist);
					//console.log("no pi")
				} else {
					originangle = Math.atan(xdist/ydist)+Math.PI;
					//console.log("+pi")
				}
				return [xdist, ydist, originangle];
			}

			function randomRange(low, high){
				var difference = high-low;
				var output = Math.random();
				output = Math.round(output*(difference+0.99)-0.5)+low;
				return output;
			}

			function line(x, y, angle, length, color){
					ctx.lineWidth = 3;
					ctx.strokeStyle = color;
					ctx.beginPath();
					ctx.moveTo(x, y);
					ctx.lineTo(x + length*Math.sin(angle), y + length*Math.cos(angle));
					ctx.closePath();
					ctx.stroke();
			}


			function onMouseMove(event){

				mouseX = event.pageX;
				mouseY = event.pageY;
				//if(100>mouseX){
				//	mouseX = 100
				//} else if(mouseX>canvas.width-100) {
				//	mouseX = canvas.width-100
				//}
				//if(100>mouseY){
				//	mouseY = 100
				//} else if(mouseY>canvas.height-100) {
				//	mouseY = canvas.height-100
				//}
			}

			function onClick(event){
				if(overlay && Over.x > Over.width-4){
							Over.slide = 0;
							overlay = !overlay;
						} else if(overlay == false && Over.x < 4){
							Over.slide = 0;
							overlay = !overlay;
						}

			}

			function onMouseEnter(event){
				//console.log("mouse is in")
				mousein = true;

			}

			function onMouseLeave(event){
				//console.log("mouse is out")
				mousein = false;
			}


			canvas.addEventListener("wheel", scroll);
			canvas.addEventListener('mousemove', onMouseMove);
			canvas.addEventListener('mousedown', onClick);
			canvas.addEventListener('mouseenter', onMouseEnter);
			canvas.addEventListener('mouseleave', onMouseLeave);
			window.onresize = canvasResize;

			document.addEventListener('keydown', (event) => {
				const keyName = event.key;

				if (keyName === 'Control') {
					// do not alert when only Control key is pressed.
					return;
			  	}
				if (event.ctrlKey) {
					// Even though event.key is not 'Control' (e.g., 'a' is pressed),
					// event.ctrlKey may be true if Ctrl key is pressed at the same time.
					return;
				} else {
					if(keyName == " " && boids.length>0){
						console.log("spacebar");
						pause = !pause;
					} else if(keyName == "Escape"){
						console.log("escape");
						if(overlay && Over.x > Over.width-4){
							Over.slide = 0;
							overlay = !overlay;
						} else if(overlay == false && Over.x < 4){
							Over.slide = 0;
							overlay = !overlay;
						}

					} else if(keyName == "Shift"){
						return;
					} else if(keyName == "ArrowUp"){
						Over.select--;
						if(Over.select==-1){
							Over.select = 3;
						}
					} else if(keyName == "ArrowDown"){
						Over.select++;
						if(Over.select==4){
							Over.select = 0;
						}
					} else if(keyName == "ArrowLeft"){
						sli(-1);
					} else if(keyName == "ArrowRight"){
						sli(1);
					} else {
						console.log(keyName);
					}

				}
			}, false);

			function sli(effect){
				switch(Over.select){
					case 0:  //boid species 1


						break;
					case 1:


						break;
					case 2:


						break;
					case 3:


						break;
				}
			}


			class Boid{
				constructor(){
					this.x = randomRange(0, canvas.width);
					this.y = randomRange(0, canvas.height);
					this.angle = 2*Math.random()*Math.PI;
					this.va = 0;
					this.speed = randomRange(3, 12);
					this.size = randomRange(7, 9);
					this.r = randomRange(160, 240);
					this.g = randomRange(160, 240);
					this.b = randomRange(160, 240);
					this.pressure = 0.8;
					//this.color = 'rgba('+randomRange(140, 240)+', '+randomRange(140, 240)+', '+randomRange(140, 240)+', '+1+')';
				}
				calc(index){
					var xspeed = 0;
					var yspeed = 0;

					var avoidx = 0;
					var avoidy = 0;
					this.pressure = 0.8;
					for(var i = 0; i < boids.length; i++){
						if(index != i){
							var boidist = dist(this, boids[i].x, boids[i].y);
							var boiddit = Math.sqrt(Math.pow(boidist[0], 2)+Math.pow(boidist[1], 2)); // distance to boid
							var repel;
							if(boiddit < 31){
								repel = (-4)*boiddit+178+bump;
								this.pressure = this.pressure + boiddit*0.002;
							} else if(boiddit > 200){
								repel = 0;
								if(220<=boiddit && boiddit<=228){
									//console.log(boiddit)
									repel = -(boiddit-220)*(boiddit-230)*repelbump; // DAMN
								}
							} else {
								if(boiddit < 80){
									this.pressure = this.pressure + boiddit*0.0003;
								}
								repel = (boiddit-50)*(boiddit-200)/(50*(boiddit-30));
							}


							avoidx = avoidx + repel*Math.sin(boidist[2]);
							avoidy = avoidy + repel*Math.cos(boidist[2]);

							//line(this.x, this.y, boiddit[2], boidist, 'pink');
							//console.log(boidist, boiddit, repel)
						}
					}

					avoidx = 0.01*avoidx + avoidx/boids.length;
					avoidy = 0.01*avoidy + avoidy/boids.length;

					var windx = 0;
					var windy = 0;
					var borderslope = borderwidth/borderstrength;
					if(borderwidth>=this.x){
						windx = -this.x/borderslope+borderstrength;
					} else if(this.x>=canvas.width-borderwidth) {
						windx = -(this.x-canvas.width)/borderslope-borderstrength;
					}

					if(borderwidth>=this.y){
						windy = -this.y/borderslope+borderstrength;
					} else if(this.y>=canvas.height-borderwidth) {
						windy = -(this.y-canvas.height)/borderslope-borderstrength;
					}


					var xccel = - avoidx + windx/25;
					var yccel = - avoidy + windy/25;

					if(-maxcell>xccel){
						xccel = -maxcell;
					} else if(xccel>maxcell){
						xccel = maxcell;
					}
					if(-maxcell>yccel){
						yccel = -maxcell;
					} else if(yccel>maxcell){
						yccel = maxcell;
					}

					xspeed = (this.speed * Math.sin(this.angle)+xccel)*friction;
					yspeed = (this.speed * Math.cos(this.angle)+yccel)*friction;

					//console.log(xspeed, yspeed);

					if(-maxspeed>xspeed){
						xspeed = -maxspeed;
					} else if(xspeed>maxspeed){
						xspeed = maxspeed;
					}
					if(-maxspeed>yspeed){
						yspeed = -maxspeed;
					} else if(yspeed>maxspeed){
						yspeed = maxspeed;
					}

					/*
					var maxvx = maxspeed * Math.sin(this.angle)
					var maxvy = maxspeed * Math.cos(this.angle)
					if(-maxvx>xspeed){
						xspeed = -maxvx
					} else if(xspeed>maxvx){
						xspeed = maxvx
					}
					if(-maxvy>yspeed){
						yspeed = -maxvy
					} else if(yspeed>maxvy){
						yspeed = maxvy
					}
					*/

					var va = 0;
					if(yspeed >= 0){
						//console.log("down")
						this.va = Math.atan(xspeed/yspeed) - this.angle;

					} else {
						this.va = Math.atan(xspeed/yspeed)+Math.PI - this.angle;
						//console.log("up")
					}

					/*
					if(this.va>maxturn){
						this.va = maxturn;
					} else if(this.va<-maxturn){
						this.va = -maxturn;
					}
					*/
					var mom = dist(this, mouseX, mouseY);

					var facecursor = mom[2]-this.angle;
					if(facecursor > Math.PI){
						while(facecursor > Math.PI){
							facecursor += -2*Math.PI;
						}
					} else if(facecursor < -Math.PI){
						while(facecursor < Math.PI){
							facecursor += 2*Math.PI;
						}
					}

					this.angle = this.angle + this.va;
					if(mousein){
						this.angle += (facecursor)*mouseinfluence;
					}
					this.speed = Math.sqrt(Math.pow(xspeed, 2)+Math.pow(yspeed, 2));


					this.x = this.x + xspeed; /* + (1 + pressure*1.2)*Math.sin(this.angle); */
					this.y = this.y + yspeed; /* + (1 + pressure*1.2)*Math.cos(this.angle); */

				}
				draw(){
					this.size = Math.sqrt(this.speed+1.2)*1.8/this.pressure+1.5;

					var red = this.r * Math.sin(this.angle)/3 + 174;
					var green = this.g * Math.sin(this.angle+2*Math.PI/3)/3 + 174;
					var blue = this.b * Math.sin(this.angle+4*Math.PI/3)/3 + 174;

					if(-20<this.x<canvas.width+20 && -20<this.y<canvas.height+20){
						var lighten = 0;
						if(highlights){
							lighten = 6*(Math.pow(1.7,this.pressure*10-9)-1);
						}
						if(auras){
						ctx.fillStyle = 'rgba('+red+', '+green+', '+blue+', '+(0.03+(this.speed)/140)+')';
						ctx.beginPath();
    					ctx.arc(this.x, this.y, 3*this.size, 0, 2 * Math.PI);
   						ctx.fill();
						}

						ctx.lineWidth = this.size;
						ctx.strokeStyle = 'rgba('+(red+lighten)+', '+(green+lighten)+', '+(blue+lighten)+', '+1+')';
						ctx.lineJoin = 'round';
						ctx.beginPath();
						ctx.moveTo(this.x, this.y);
						ctx.lineTo(this.x+this.size*Math.sin(this.angle+1.35*Math.PI), this.y+this.size*Math.cos(this.angle+1.35*Math.PI));
						ctx.lineTo(this.x+this.size*1.3*Math.sin(this.angle), this.y+this.size*1.3*Math.cos(this.angle));
						ctx.lineTo(this.x+this.size*Math.sin(this.angle+0.65*Math.PI), this.y+this.size*Math.cos(this.angle+0.65*Math.PI));
						ctx.lineTo(this.x, this.y);
						ctx.closePath();
						ctx.stroke();



						//line(this.x, this.y, distance[2], Math.sqrt(Math.pow(distance[0], 2)+Math.pow(distance[1], 2))/6, 'green');
						//line(this.x, this.y, Math.PI/2, distance[0]/6, 'yellow');
						//line(this.x, this.y, Math.PI, -distance[1]/6, 'yellow');
					}
				}
			}


			class Overlay{
				constructor(){
					this.slide = 0;
					this.x = 0;
					this.width = canvas.width/3;
					this.select = 0;
				}
				calc(neg){
					if(this.x<this.width -1|| neg > 0){
<<<<<<< HEAD
						this.slide += 1
						this.x = this.width/(1+Math.pow(Math.E, (neg*180/this.width)*(this.slide-15))) //logistic sweepy curve
						console.log(this.slide, this.x)
=======
						this.slide += 1;
						this.x = this.width/(1+Math.pow(Math.E, (neg*100/this.width)*(this.slide-15))); //logistic sweepy curve
						console.log(this.slide, this.x);
>>>>>>> 79272e607ce614097dbbe1fd55571ee47b1deea2
					} else if (this.x>this.width-1){
						this.x = this.width;
					}

				}
				slider(y, upper, lower, value, text, index){
					if(index == this.select){
						ctx.fillStyle = canvascolor = "rgba(230, 230, 255, 0.05)";
						ctx.fillRect(this.x-49*this.width/50, y-115, 48*this.width/50, 200);
					}
					ctx.fillStyle = canvascolor = "rgba(19, 23, 26, 0.2)";
					ctx.fillRect(this.x-24*this.width/25, y-103, 23*this.width/25, 176);

					var diff = upper-lower;
					var point = (value/diff)*(3*this.width/4);
					ctx.lineWidth = canvas.height/100;
					ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
					ctx.lineJoin = 'round';
					ctx.beginPath();
					ctx.moveTo(this.x-7*this.width/8, y);
					ctx.lineTo(this.x-this.width/8, y)
					ctx.fillStyle = 'rgba(50, 50, 50, 0.5)';
					//ctx.moveTo(this.x-7*this.width/8+point, y);
					ctx.arc(this.x-7*this.width/8+point, y, canvas.height/50, 0, 2 * Math.PI);
   					ctx.fill();
					ctx.closePath();
					ctx.stroke();

					ctx.font = canvas.width / 120 + "px Arial";
					ctx.fillStyle = 'rgba(200, 200, 255, 0.5)';
					ctx.fillText(Math.round(value, 2), this.x-7*this.width/8+point-10, y+50);

					ctx.font = canvas.width / 70 + "px Arial";
					ctx.fillStyle = 'rgba(200, 200, 255, 0.5)';
					ctx.fillText(text, this.x-7*this.width/8, y-50);

				}
				draw(){
					ctx.fillStyle = "rgba(114, 137, 218, 0.3)";
					ctx.fillRect(0, 0, this.x, canvas.height);

					ctx.font = canvas.width / 60 + "px Arial";
					ctx.fillStyle = 'rgba(200, 200, 255, 0.5)';
					ctx.fillText("Pause the boids with spacebar.", this.x-19*this.width/20, 55);
					ctx.fillText("Use arrow keys to navigate menu.", this.x-19*this.width/20, 55+canvas.width / 58);
					ctx.fillText("Gaming.", this.x-19*this.width/20, 55+canvas.width / 29);
					for(var i = 0; i < 4; i++){
						this.slider(280+200*i, slidata[i][0], slidata[i][1], slidata[i][2], slidata[i][3], i);

					}

				}
			}
			Over = new Overlay();

			setInterval(function(){
				if(boids.length != 0){
					slidata[0][2] = boids.length;
					if(!pause){
						ctx.fillStyle = canvascolor;
						ctx.fillRect(0, 0, canvas.width, canvas.height);
						if(mousein){
							ctx.fillStyle = 'rgba(255, 255, 255, 0.04)';
							ctx.beginPath();
    							ctx.arc(mouseX, mouseY, 50, 0, 2 * Math.PI);
   							ctx.fill();
						}
						for(var i = 0; i < boids.length; i++){
							boids[i].calc(i);
							boids[i].draw();
						}
						ctx.font = canvas.width / 15 + "px Arial";
						ctx.fillStyle = '#7289DA';
						strboid = boids.length.toString();
						ctx.fillText(boids.length, canvas.width - canvas.width*strboid.length/27 - canvas.width/30, canvas.width / 15);
					} else {
						ctx.font = canvas.width / 15 + "px Arial";
						ctx.fillStyle = '#7289DA';
						ctx.fillText("paused", 3*canvas.width/4, canvas.height-100);
					}
				} else {
					ctx.fillStyle = canvascolor;
					ctx.fillRect(0, 0, canvas.width, canvas.height);
					ctx.font = canvas.width / 15 + "px Arial";
					ctx.fillStyle = '#7289DA';
					ctx.fillText("scroll for boids :D", 80, canvas.height-100);
					ctx.fillStyle = canvascolor;
				}
				if(overlay){
					Over.calc(-1);
					Over.draw();
				} else if (Over.x>2){
					Over.calc(1);
					Over.draw();
				}

			}, 14);


			function scroll(event){
				var x = mouseX;
				var y = mouseY;
				delta = event.deltaX + event.deltaY + event.deltaZ;
				if(delta<=-1 && !pause){
				//console.log(mouseX, mouseY)
					for(var i = 0; i < scrollnumber; i++){
						boid = new Boid();
						if(100>x){
							x = 100;
						} else if(x>canvas.width-100) {
							x = canvas.width-100;
						}
						if(100>y){
							y = 100;
						} else if(y>canvas.height-100) {
							y = canvas.height-100;
						}
						boid.x = x + randomRange(-50, 50);
						boid.y = y + randomRange(-50, 50);
						boids.push(boid);
						if(boids.length>250){
							boids.shift();
						}
					}
				} else if(delta>=1 && !pause){
					if(boids.length>0){
						for(var i = 0; i < scrollnumber; i++){
							boids.shift();
							if(boids.length==0){
								break;
							}
						}

					}
				}

			}


			function canvasResize() {
				canvas.width  = window.innerWidth;
				canvas.height = window.innerHeight;
				ctx.fillStyle = '#13171A';
				//ctx.fillStyle = canvascolor;
				ctx.fillRect(0, 0, canvas.width, canvas.height);
				if(boids.length == 0){
					ctx.font = canvas.width / 15 + "px Arial";
					ctx.fillStyle = '#7289DA';
					ctx.fillText("scroll for boids :D", 80, canvas.height-100);
				}
				Over.width = canvas.width/3;
				if(Over.x > Over.width){
					Over.x = Over.width;
				}
			}
			canvasResize();

		</script>
	</body>
</html>
